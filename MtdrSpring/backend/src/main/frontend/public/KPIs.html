<!doctype html>
<html lang="es">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>KPIs</title>
  <link rel="stylesheet" href="Css/KPIs.css" />
  <link href="https://api.fontshare.com/v2/css?f[]=panchang@500,600,700,800,900&display=swap" rel="stylesheet">

  <!-- Sprite de íconos -->
  <svg xmlns="http://www.w3.org/2000/svg" style="display:none">
    <!-- Dashboard -->
    <symbol id="i-dashboard" viewBox="0 0 24 24" fill="none" stroke="currentColor">
      <path stroke-width="1.6" d="M3 3h8v8H3zM13 3h8v5h-8zM13 10h8v11h-8zM3 13h8v8H3z" />
    </symbol>
    <!-- Equipos -->
    <symbol id="i-users" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.6" stroke-linecap="round"
      stroke-linejoin="round">
      <path d="M17 21v-2a4 4 0 0 0-3-3.87" />
      <path d="M7 21v-2a4 4 0 0 1 3-3.87" />
      <circle cx="12" cy="7" r="4" />
      <path d="M5.5 8a3.5 3.5 0 1 0 0 7" />
      <path d="M18.5 8a3.5 3.5 0 1 1 0 7" />
    </symbol>
    <!-- Proyectos -->
    <symbol id="i-folder" viewBox="0 0 24 24" fill="none" stroke="currentColor">
      <path stroke-width="1.6" d="M3 7h6l2 2h10v9a3 3 0 0 1-3 3H6a3 3 0 0 1-3-3z" />
    </symbol>
    <!-- Tareas -->
    <symbol id="i-board" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
      stroke-linejoin="round">
      <rect width="8" height="4" x="8" y="2" rx="1" ry="1" />
      <path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2" />
      <path d="M12 11h4" />
      <path d="M12 16h4" />
      <path d="M8 11h.01" />
      <path d="M8 16h.01" />
    </symbol>
    <!-- KPIs -->
    <symbol id="i-chart" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.6" stroke-linecap="round"
      stroke-linejoin="round">
      <path d="M12 16v5" />
      <path d="M16 14v7" />
      <path d="M20 10v11" />
      <path d="m22 3-8.646 8.646a.5.5 0 0 1-.708 0L9.354 8.354a.5.5 0 0 0-.707 0L2 15" />
      <path d="M4 18v3" />
      <path d="M8 14v7" />
    </symbol>
    <!-- Notificaciones -->
    <symbol id="i-bell" viewBox="0 0 24 24" fill="none" stroke="currentColor">
      <path stroke-width="1.6" d="M18 8a6 6 0 1 0-12 0c0 7-3 7-3 7h18s-3 0-3-7" />
      <path stroke-width="1.6" d="M13.73 21a2 2 0 0 1-3.46 0" />
    </symbol>
    <!-- Ajustes -->
    <symbol id="i-gear" viewBox="0 0 24 24" fill="none" stroke="currentColor">
      <circle cx="12" cy="12" r="3" />
      <path stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round"
        d="M9.671 4.136a2.34 2.34 0 0 1 4.659 0 2.34 2.34 0 0 0 3.319 1.915 2.34 2.34 0 0 1 2.33 4.033 2.34 2.34 0 0 0 0 3.831 2.34 2.34 0 0 1-2.33 4.033 2.34 2.34 0 0 0-3.319 1.915 2.34 2.34 0 0 1-4.659 0 2.34 2.34 0 0 0-3.32-1.915 2.34 2.34 0 0 1-2.33-4.033 2.34 2.34 0 0 0 0-3.831A2.34 2.34 0 0 1 6.35 6.051a2.34 2.34 0 0 0 3.319-1.915" />
    </symbol>
  </svg>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
</head>


<body>

  <!-- Topbar -->
  <header class="topbar">
    <div class="brand">
      <h1 class="logo-text">TMDV</h1>
    </div>
    <div class="topbar-right">
      <div class="user-circle" title="Usuario">U</div>
      <a href="/index.html" class="logout-btn">Salir</a>
    </div>
  </header>

  <div class="app">
    <!-- Sidebar -->
    <aside class="aside">
      <nav class="menu">
        <a class="mi" href="/dashboard.html">
          <svg class="ico">
            <use href="#i-dashboard" />
          </svg>
          <span>Dashboard</span>
        </a>
        <a class="mi" href="/Equipos.html">
          <svg class="ico">
            <use href="#i-users" />
          </svg>
          <span>Equipos</span>
        </a>
        <a class="mi" href="/projects.html">
          <svg class="ico">
            <use href="#i-folder" />
          </svg>
          <span>Proyectos</span>
        </a>
        <a class="mi" href="/tarea.html">
          <svg class="ico">
            <use href="#i-board" />
          </svg>
          <span>Mis Tareas</span>
        </a>
        <a class="mi active" href="#">
          <svg class="ico">
            <use href="#i-chart" />
          </svg>
          <span>KPIs</span>
        </a>
        <a class="mi" href="/notifications.html">
          <svg class="ico">
            <use href="#i-bell" />
          </svg>
          <span>Notificaciones</span>
        </a>
        <a class="mi" href="/settings.html">
          <svg class="ico">
            <use href="#i-gear" />
          </svg>
          <span>Ajustes</span>
        </a>
      </nav>
    </aside>

    <!-- Contenido principal -->
    <main class="main">
      <section class="card card-soft">
        <h1 class="h4">KPIs de productividad y calidad</h1>
        <div class="stats-grid">
          <div class="stat">
            <div id="taskCompletionValue" class="value">--%</div>
            <div class="label">Task Completion</div>
          </div>
          <div class="stat">
            <div id="avgResolutionValue" class="value">--h</div>
            <div class="label">Tiempo prom. resolución tareas</div>
          </div>
          <div class="stat">
            <div id="individualKpiValue" class="value">--h</div>
            <div class="label">Individual KPI Time</div>
          </div>
          <div class="stat">
            <div class="value">76%</div>
            <div class="label">Uso de OCI</div>
          </div>
        </div>
      </section>

      <section class="charts">
        <article class="card">
          <h3 class="h6">% tareas completadas por sprint</h3>
          <canvas id="barChart"></canvas>
        </article>
        <article class="card">
          <h3 class="h6">Horas reales vs planificadas</h3>
          <canvas id="lineChart"></canvas>
        </article>
      </section>
    </main>
  </div>

  <script>
    // Datos iniciales para los gráficos (se actualizan opcionalmente después)
    // bar chart: inicialmente 3 categorías (To Do, In Progress, Done)
    const statusLabels = ["To Do", "In Progress", "Done"];
    const statusInitial = [0, 0, 0];

    // hours per project will be loaded from backend

    // Crear charts y exponer instancias para poder actualizarlos después
    window.barChartInstance = new Chart(document.getElementById("barChart"), {
      type: "bar",
      data: {
        labels: statusLabels,
        datasets: [{
          label: "Cantidad de tareas",
          data: statusInitial,
          backgroundColor: ["#F59E0B", "#3B82F6", "#10B981"]
        }]
      },
      options: {
        scales: {
          y: {
            beginAtZero: true,
            min: 0,
            max: 20,
            ticks: {
              stepSize: 1
            }
          }
        }
      }
    });

    // lineChart inicial vacío; se rellenará con proyectos en loadProjectHours()
    window.lineChartInstance = new Chart(document.getElementById("lineChart"), {
      type: "line",
      data: {
        labels: [],
        datasets: [
          {
            label: "Reales",
            data: [],
            borderColor: "#E1261C",
            backgroundColor: "#E1261C",
            fill: false,
            tension: 0.2
          },
          {
            label: "Planificadas",
            data: [],
            borderColor: "#374151",
            backgroundColor: "#374151",
            borderDash: [5, 5],
            fill: false,
            tension: 0.2
          }
        ]
      },
      options: {
        scales: {
          y: {
            beginAtZero: true,
            min: 0,
            max: 20,
            ticks: {
              stepSize: 1
            }
          }
        }
      }
    });

    // Cálculo dinámico del % de tareas completadas desde /api/tasks
    async function loadTaskCompletion() {
      try {
        const userEmail = localStorage.getItem('userEmail');
        const headers = {};
        let url = '/api/tasks';
        let currentUser = null;
        if (userEmail) {
          headers['X-User-Email'] = userEmail;
          currentUser = userEmail;
        } else {
          const qEmail = new URLSearchParams(location.search).get('email');
          if (qEmail) {
            url += '?email=' + encodeURIComponent(qEmail);
            currentUser = qEmail;
          }
        }

        const res = await fetch(url, { headers });
        if (!res.ok) throw new Error('Error fetching tasks: ' + res.status);
        const tasks = await res.json();

        const total = Array.isArray(tasks) ? tasks.length : 0;
        const completedStatuses = ['done', 'completed', 'finalizado', 'completado', 'terminado', 'closed', 'hecho'];
        const completedTasks = (tasks || []).filter(t => {
          const s = (t.status || '').toString().toLowerCase();
          return completedStatuses.some(cs => s.includes(cs));
        });

        // Task Completion %
        const completed = completedTasks.length;
        const pct = total === 0 ? 0 : Math.round((completed / total) * 100);
        const pctEl = document.getElementById('taskCompletionValue');
        if (pctEl) pctEl.textContent = pct + '%';

        // Tiempo promedio de resolución (sobre tareas finalizadas retornadas)
        const sumRealHours = completedTasks.reduce((acc, t) => {
          const v = parseFloat(t.realHours);
          return acc + (Number.isFinite(v) ? v : 0);
        }, 0);
        const avg = completed === 0 ? 0 : (sumRealHours / completed);
        function formatHours(h) {
          if (!Number.isFinite(h)) return 'N/A';
          return (Math.round(h * 10) / 10) + 'h';
        }
        const avgEl = document.getElementById('avgResolutionValue');
        if (avgEl) avgEl.textContent = completed === 0 ? '0h' : formatHours(avg);

        // Individual KPI Time:
        // Determinar usuario para el KPI (preferir currentUser, si no intentar inferir)
        let userKey = null;
        if (currentUser) {
          userKey = currentUser.toString().toLowerCase();
        } else if (Array.isArray(tasks) && tasks.length === 1) {
          userKey = (tasks[0].assigneeId || tasks[0].userEmail || '').toString().toLowerCase();
        }
        // Filtrar tareas finalizadas asignadas al usuario
        const completedForUser = userKey
          ? completedTasks.filter(t => {
            const a = (t.assigneeId || t.userEmail || '').toString().toLowerCase();
            return a === userKey;
          })
          : []; // si no hay userKey, no podemos calcular individual
        const userCount = completedForUser.length;
        const userSum = completedForUser.reduce((acc, t) => {
          const v = parseFloat(t.realHours);
          return acc + (Number.isFinite(v) ? v : 0);
        }, 0);
        const userAvg = userCount === 0 ? 0 : (userSum / userCount);
        const individualEl = document.getElementById('individualKpiValue');
        if (individualEl) {
          individualEl.textContent = userCount === 0 ? '0h' : formatHours(userAvg);
        }

        // Mostrar tiempo promedio global de todas las tareas (todos los proyectos, todas las tareas con realHours)
        try {
          const resGlobal = await fetch('/api/tasks/avg-resolution/all-tasks');
          if (resGlobal.ok) {
            const g = await resGlobal.json();
            const globalAvg = parseFloat(g.avgResolutionHoursAllTasks);
            const avgEl = document.getElementById('avgResolutionValue');
            if (avgEl) {
              function formatHours(h) {
                if (!Number.isFinite(h)) return 'N/A';
                return (Math.round(h * 10) / 10) + 'h';
              }
              avgEl.textContent = Number.isFinite(globalAvg) ? formatHours(globalAvg) : 'N/A';
            }
          }
        } catch (e) {
          console.warn('Failed to load global avg resolution (all tasks):', e);
        }

        // Calcular conteos por estado y actualizar barChart (To Do / In Progress / Done)
        if (window.barChartInstance && Array.isArray(tasks)) {
          const doneStatuses = ['done', 'completed', 'finalizado', 'completado', 'terminado', 'closed', 'hecho'];
          const inProgressStatuses = ['in progress', 'doing', 'en proceso', 'progreso', 'doing', 'inprogress'];
          // contar
          let todoCount = 0, inProgressCount = 0, doneCount = 0;
          tasks.forEach(t => {
            const s = (t.status || '').toString().toLowerCase();
            const isDone = doneStatuses.some(ds => s.includes(ds)) || (t.completedAt != null);
            if (isDone) {
              doneCount++;
            } else if (inProgressStatuses.some(ip => s.includes(ip))) {
              inProgressCount++;
            } else {
              todoCount++;
            }
          });
          window.barChartInstance.data.labels = ["To Do", "In Progress", "Done"];
          window.barChartInstance.data.datasets = [{
            label: "Cantidad de tareas",
            data: [todoCount, inProgressCount, doneCount],
            backgroundColor: ["#F59E0B", "#3B82F6", "#10B981"]
          }];
          window.barChartInstance.update();
        }
      } catch (err) {
        console.error(err);
        const pctEl = document.getElementById('taskCompletionValue');
        if (pctEl) pctEl.textContent = 'N/A';
        const avgEl = document.getElementById('avgResolutionValue');
        if (avgEl) avgEl.textContent = 'N/A';
        const individualEl = document.getElementById('individualKpiValue');
        if (individualEl) individualEl.textContent = 'N/A';
      }
    }

    // Cargar horas por proyecto y actualizar lineChart (eje X = proyectos, eje Y = horas)
    // Reemplaza la función loadProjectHours actual por esta versión más robusta:
    async function loadProjectHours() {
      try {
        // 1) Determinar usuario (email -> userId)
        let userEmail = localStorage.getItem('userEmail');
        if (!userEmail) {
          const qEmail = new URLSearchParams(location.search).get('email');
          if (qEmail) userEmail = qEmail;
        }
        if (!userEmail) {
          console.warn('No hay email de usuario en localStorage ni en querystring. No se cargan proyectos por usuario.');
          return;
        }

        // Obtener userId desde backend
        let userId = null;
        try {
          const rUser = await fetch('/usuarios/by-email?email=' + encodeURIComponent(userEmail));
          if (!rUser.ok) throw new Error('User not found: ' + rUser.status);
          const userObj = await rUser.json();
          userId = userObj.id || userObj.usuarioId || userObj.usuario_id || null;
        } catch (err) {
          console.warn('No se pudo obtener userId por email:', err);
          return;
        }
        if (!userId) {
          console.warn('Usuario no tiene id válido:', userId);
          return;
        }

        // 2) Obtener proyectos del usuario
        const rProjects = await fetch('/proyectos/mios/' + encodeURIComponent(userId) + '/stats');
        if (!rProjects.ok) throw new Error('Error cargando proyectos del usuario: ' + rProjects.status);
        const userProjects = await rProjects.json();
        if (!Array.isArray(userProjects) || userProjects.length === 0) {
          console.info('Usuario no tiene proyectos.');
          // limpiar gráfico
          window.lineChartInstance.data.labels = [];
          window.lineChartInstance.data.datasets[0].data = [];
          window.lineChartInstance.data.datasets[1].data = [];
          window.lineChartInstance.update();
          return;
        }

        const projectIds = userProjects.map(p => p.id || p.projectId || p.proyectoId).filter(Boolean);

        // 3) Intentar obtener horas con endpoints convenientes
        let projectHoursData = null; // array [{ projectId, projectName, estimatedHours, realHours }, ...]

        // Helper: convierte/normaliza un objeto devuelto por backend a la forma que necesitamos
        function normalizeEntry(raw) {
          if (!raw) return null;
          const id = raw.projectId ?? raw.id ?? raw.proyectoId ?? null;
          const name = raw.projectName ?? raw.nombreProyecto ?? raw.name ?? raw.project_name ?? ('P' + id);
          // posibles campos que contienen horas planificadas/estimadas
          const estimated = Number(raw.estimatedHours ?? raw.plannedHours ?? raw.planned_hours ?? raw.estimated_hours ?? raw.estimated ?? raw.planned ?? 0) || 0;
          // posibles campos que contienen horas reales/registradas
          const real = Number(raw.realHours ?? raw.actualHours ?? raw.real_hours ?? raw.actual_hours ?? raw.real ?? raw.loggedHours ?? 0) || 0;
          return { projectId: id, projectName: name, estimatedHours: estimated, realHours: real, raw };
        }

        // 3.a) Intentar batch: /proyectos/horas?ids=1,2,3
        try {
          const q = projectIds.join(',');
          const r = await fetch('/proyectos/horas?ids=' + encodeURIComponent(q));
          if (r.ok) {
            const all = await r.json();
            if (Array.isArray(all)) {
              projectHoursData = all.map(normalizeEntry).filter(Boolean);
            }
          }
        } catch (err) {
          console.debug('Batch /proyectos/horas?ids=... falló:', err);
        }

        // 3.b) Si no, intentar traer /proyectos/horas (todo) y filtrar
        if (!projectHoursData) {
          try {
            const rAll = await fetch('/proyectos/horas');
            if (rAll.ok) {
              const all = await rAll.json();
              if (Array.isArray(all)) {
                // normalizar y filtrar por projectIds
                const normalized = all.map(normalizeEntry).filter(Boolean);
                const setIds = new Set(projectIds.map(String));
                projectHoursData = normalized.filter(x => x.projectId && setIds.has(String(x.projectId)));
              }
            }
          } catch (err) {
            console.debug('/proyectos/horas (full) falló:', err);
          }
        }

        // 3.c) Si aún no hay datos, intentar por proyecto individual: /proyectos/{id}/horas
        if (!projectHoursData) {
          const arr = [];
          await Promise.all(projectIds.map(async (pid) => {
            try {
              const r = await fetch('/proyectos/' + encodeURIComponent(pid) + '/horas');
              if (r.ok) {
                const raw = await r.json();
                const n = normalizeEntry(raw);
                if (n) arr.push(n);
              } else {
                // puede que devuelva 404 o similar; ignorar
                console.debug('No data for project hours endpoint for', pid, r.status);
              }
            } catch (err) {
              console.debug('Error fetching /proyectos/{id}/horas for', pid, err);
            }
          }));
          if (arr.length) projectHoursData = arr;
        }

        // 4) Fallback: si aún faltan valores 'estimated' o 'real', obtener tareas por proyecto y sumar campos
        // También usamos este paso si algún proyecto tiene estimatedHours===0 y realHours===0 (posible falta de datos)
        async function fetchTasksAndAggregate(pid) {
          try {
            // Intentar endpoint con projectId
            const r = await fetch('/api/tasks?projectId=' + encodeURIComponent(pid));
            if (!r.ok) return null;
            const tasks = await r.json();
            if (!Array.isArray(tasks)) return null;

            // Sumar posibles campos
            let sumPlanned = 0;
            let sumEstimated = 0;
            let sumReal = 0;
            tasks.forEach(t => {
              // varios nombres posibles
              const p = Number(t.plannedHours ?? t.planned_hours ?? t.estimatedHours ?? t.estimated_hours ?? t.estimated ?? t.planned ?? 0) || 0;
              const rH = Number(t.realHours ?? t.real_hours ?? t.actualHours ?? t.actual_hours ?? t.loggedHours ?? 0) || 0;
              sumPlanned += p;
              sumEstimated += p; // si no hay diferencia entre planned/estimated usamos p
              sumReal += rH;
            });
            return { estimatedHours: sumEstimated, realHours: sumReal };
          } catch (err) {
            console.debug('Error agregando tareas para proyecto', pid, err);
            return null;
          }
        }

        // Asegurarnos que projectHoursData contenga una entrada por cada proyecto del usuario
        const mapById = new Map();
        if (projectHoursData && projectHoursData.length) {
          projectHoursData.forEach(e => { if (e && e.projectId) mapById.set(String(e.projectId), e); });
        }
        // Añadir entradas faltantes (si el endpoint no devolvió uno por cada proyecto)
        for (const p of userProjects) {
          const pid = String(p.id || p.projectId || p.proyectoId || '');
          if (!pid) continue;
          if (!mapById.has(pid)) {
            // construir objeto básico desde metadata del proyecto
            const name = p.projectName || p.nombreProyecto || p.name || ('P' + pid);
            mapById.set(pid, { projectId: pid, projectName: name, estimatedHours: 0, realHours: 0, raw: p });
          }
        }

        // Para cada proyecto, si valores son 0 o faltantes, intentar agregar por tareas
        const finalData = [];
        for (const [pid, ent] of mapById.entries()) {
          let normalized = Object.assign({}, ent); // copia
          // si both are 0, intentar calcular
          if ((!normalized.estimatedHours || normalized.estimatedHours === 0) || (!normalized.realHours || normalized.realHours === 0)) {
            const agg = await fetchTasksAndAggregate(pid);
            if (agg) {
              // preferimos datos existentes, pero si están en 0 los reemplazamos
              normalized.estimatedHours = (normalized.estimatedHours && normalized.estimatedHours > 0) ? normalized.estimatedHours : (agg.estimatedHours || 0);
              normalized.realHours = (normalized.realHours && normalized.realHours > 0) ? normalized.realHours : (agg.realHours || 0);
            }
          }
          // Como usuario pidió "lo que va del proyecto" usamos realHours acumuladas y estimated como total planificado
          finalData.push({
            projectId: normalized.projectId,
            projectName: normalized.projectName,
            estimatedHours: Number.isFinite(Number(normalized.estimatedHours)) ? Number(normalized.estimatedHours) : 0,
            realHours: Number.isFinite(Number(normalized.realHours)) ? Number(normalized.realHours) : 0
          });
        }

        // Ordenar por nombre o por id (puedes cambiar)
        finalData.sort((a, b) => (a.projectName || '').localeCompare(b.projectName || ''));

        // 5) Actualizar chart con SOLO estos proyectos
        const labels = finalData.map(d => d.projectName);
        const estimated = finalData.map(d => d.estimatedHours);
        const real = finalData.map(d => d.realHours);

        window.lineChartInstance.data.labels = labels;
        window.lineChartInstance.data.datasets[0].data = real;       // Reales
        window.lineChartInstance.data.datasets[1].data = estimated;  // Planificadas
        window.lineChartInstance.update();

      } catch (err) {
        console.error('loadProjectHours error:', err);
      }
    }


    // Ejecutar al cargar la página: métricas de tareas y horas por proyecto
    loadTaskCompletion();
    loadProjectHours();
  </script>
</body>

</html>