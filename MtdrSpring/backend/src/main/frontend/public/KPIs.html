<!doctype html>
<html lang="es">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>KPIs</title>
  <link rel="stylesheet" href="Css/KPIs.css" />
  <link href="https://api.fontshare.com/v2/css?f[]=panchang@500,600,700,800,900&display=swap" rel="stylesheet">

  <!-- Sprite de √≠conos -->
  <svg xmlns="http://www.w3.org/2000/svg" style="display:none">
    <!-- Dashboard -->
    <symbol id="i-dashboard" viewBox="0 0 24 24" fill="none" stroke="currentColor">
      <path stroke-width="1.6" d="M3 3h8v8H3zM13 3h8v5h-8zM13 10h8v11h-8zM3 13h8v8H3z" />
    </symbol>
    <!-- Equipos -->
    <symbol id="i-users" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.6" stroke-linecap="round"
      stroke-linejoin="round">
      <path d="M17 21v-2a4 4 0 0 0-3-3.87" />
      <path d="M7 21v-2a4 4 0 0 1 3-3.87" />
      <circle cx="12" cy="7" r="4" />
      <path d="M5.5 8a3.5 3.5 0 1 0 0 7" />
      <path d="M18.5 8a3.5 3.5 0 1 1 0 7" />
    </symbol>
    <!-- Proyectos -->
    <symbol id="i-folder" viewBox="0 0 24 24" fill="none" stroke="currentColor">
      <path stroke-width="1.6" d="M3 7h6l2 2h10v9a3 3 0 0 1-3 3H6a3 3 0 0 1-3-3z" />
    </symbol>
    <!-- Tareas -->
    <symbol id="i-board" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
      stroke-linejoin="round">
      <rect width="8" height="4" x="8" y="2" rx="1" ry="1" />
      <path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2" />
      <path d="M12 11h4" />
      <path d="M12 16h4" />
      <path d="M8 11h.01" />
      <path d="M8 16h.01" />
    </symbol>
    <!-- KPIs -->
    <symbol id="i-chart" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.6" stroke-linecap="round"
      stroke-linejoin="round">
      <path d="M12 16v5" />
      <path d="M16 14v7" />
      <path d="M20 10v11" />
      <path d="m22 3-8.646 8.646a.5.5 0 0 1-.708 0L9.354 8.354a.5.5 0 0 0-.707 0L2 15" />
      <path d="M4 18v3" />
      <path d="M8 14v7" />
    </symbol>
    <!-- Notificaciones -->
    <symbol id="i-bell" viewBox="0 0 24 24" fill="none" stroke="currentColor">
      <path stroke-width="1.6" d="M18 8a6 6 0 1 0-12 0c0 7-3 7-3 7h18s-3 0-3-7" />
      <path stroke-width="1.6" d="M13.73 21a2 2 0 0 1-3.46 0" />
    </symbol>
    <!-- Ajustes -->
    <symbol id="i-gear" viewBox="0 0 24 24" fill="none" stroke="currentColor">
      <circle cx="12" cy="12" r="3" />
      <path stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round"
        d="M9.671 4.136a2.34 2.34 0 0 1 4.659 0 2.34 2.34 0 0 0 3.319 1.915 2.34 2.34 0 0 1 2.33 4.033 2.34 2.34 0 0 0 0 3.831 2.34 2.34 0 0 1-2.33 4.033 2.34 2.34 0 0 0-3.319 1.915 2.34 2.34 0 0 1-4.659 0 2.34 2.34 0 0 0-3.32-1.915 2.34 2.34 0 0 1-2.33-4.033 2.34 2.34 0 0 0 0-3.831A2.34 2.34 0 0 1 6.35 6.051a2.34 2.34 0 0 0 3.319-1.915" />
    </symbol>
    <!-- Exit -->
    <symbol id="i-exit" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
      stroke-linejoin="round">
      <path d="m16 17 5-5-5-5" />
      <path d="M21 12H9" />
      <path d="M9 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h4" />
    </symbol>
  </svg>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
</head>


<body>

  <!-- Topbar -->
  <header class="topbar">
    <div class="brand">
      <h1 class="logo-text">TMDV</h1>
    </div>
    <div class="topbar-right">
      <div class="user-circle" title="Usuario">U</div>
      <a href="/index.html" class="logout-btn">
        <svg class="ico-sm" aria-hidden="true">
          <use href="#i-exit" />
        </svg>
        <span>Salir</span>
      </a>
    </div>
  </header>

  <div class="app">
    <!-- Sidebar -->
    <aside class="aside">
      <nav class="menu">
        <a class="mi" href="/dashboard.html">
          <svg class="ico">
            <use href="#i-dashboard" />
          </svg>
          <span>Dashboard</span>
        </a>
        <a class="mi" href="/Equipos.html">
          <svg class="ico">
            <use href="#i-users" />
          </svg>
          <span>Equipos</span>
        </a>
        <a class="mi" href="/projects.html">
          <svg class="ico">
            <use href="#i-folder" />
          </svg>
          <span>Proyectos</span>
        </a>
        <a class="mi" href="/tarea.html">
          <svg class="ico">
            <use href="#i-board" />
          </svg>
          <span>Tareas</span>
        </a>
        <a class="mi active" href="#">
          <svg class="ico">
            <use href="#i-chart" />
          </svg>
          <span>KPIs</span>
        </a>
        <a class="mi" href="/notifications.html">
          <svg class="ico">
            <use href="#i-bell" />
          </svg>
          <span>Notificaciones</span>
        </a>
        <a class="mi" href="/settings.html">
          <svg class="ico">
            <use href="#i-gear" />
          </svg>
          <span>Ajustes</span>
        </a>
      </nav>
    </aside>

    <!-- Contenido principal -->
    <main class="main">
      <section class="card card-soft">
        <h1 class="h4">KPIs de productividad y calidad</h1>
        <div class="stats-grid">
          <div class="stat">
            <div id="taskCompletionValue" class="value">--%</div>
            <div class="label">Task Completion</div>
          </div>
          <div class="stat">
            <div id="avgResolutionValue" class="value">--h</div>
            <div class="label">Tiempo prom. resoluci√≥n tareas</div>
          </div>
          <div class="stat">
            <div id="individualKpiValue" class="value">--h</div>
            <div class="label">Individual KPI Time</div>
          </div>
          <div class="stat">
            <div id="avgIclValue" class="value">--</div>
            <div class="label">ICL Promedio Equipos</div>
          </div>
        </div>
      </section>

      <!-- NUEVO: Filtros Globales -->
      <section class="card">
        <h3 class="h6">
          <svg class="ico" style="width:24px;height:24px">
            <use href="#i-gear" />
          </svg>
          Filtros de Visualizaci√≥n
        </h3>
        <div class="filters-container">
          <div class="filter-group">
            <label class="filter-label" for="projectFilter">Proyecto</label>
            <select id="projectFilter" class="filter-select">
              <option value="">Todos los proyectos</option>
            </select>
          </div>
          <div class="filter-group">
            <label class="filter-label" for="sprintFilter">Sprint</label>
            <select id="sprintFilter" class="filter-select">
              <option value="">Todos los sprints</option>
            </select>
          </div>
          <button id="applyFilters" class="filter-button">
            <svg class="ico-sm" style="width:16px;height:16px">
              <use href="#i-chart" />
            </svg>
            Aplicar Filtros
          </button>
          <button id="clearFilters" class="clear-filters">Limpiar</button>
        </div>
        <div id="activeFilters" style="margin-top:12px;display:none;"></div>
      </section>

      <!-- Horas por Sprint -->
      <section class="card">
        <h3 class="h6">
          <svg class="ico" style="width:24px;height:24px">
            <use href="#i-chart" />
          </svg>
          Horas Trabajadas por Sprint
        </h3>
        <p style="color:var(--muted);font-size:14px;margin-bottom:20px">
          An√°lisis global del tiempo invertido durante el desarrollo del proyecto
        </p>
        <canvas id="sprintHoursChart"></canvas>
      </section>

      <!-- Horas por Developer -->
      <section class="card">
        <h3 class="h6">
          <svg class="ico" style="width:24px;height:24px">
            <use href="#i-users" />
          </svg>
          Horas Trabajadas por Developer por Sprint
        </h3>
        <p style="color:var(--muted);font-size:14px;margin-bottom:20px">
          Desempe√±o individual por sprint - Comparaci√≥n entre miembros del equipo
        </p>
        <canvas id="developerSprintChart"></canvas>
      </section>

      <!-- Tareas Terminadas -->
      <section class="card">
        <h3 class="h6">
          <svg class="ico" style="width:24px;height:24px">
            <use href="#i-board" />
          </svg>
          Tareas Terminadas por Developer por Sprint
        </h3>
        <p style="color:var(--muted);font-size:14px;margin-bottom:20px">
          Cantidad de tareas completadas por desarrollador - Comparaci√≥n de productividad entre miembros del equipo
        </p>
        <canvas id="tasksCompletedChart"></canvas>
      </section>

      <!-- Reporte Detallado -->
      <section class="card">
        <h3 class="h6">
          <svg class="ico" style="width:24px;height:24px">
            <use href="#i-board" />
          </svg>
          Reporte: Tareas Completadas por Sprint
        </h3>
        <p style="color:var(--muted);font-size:14px;margin-bottom:16px">
          Detalle de tareas finalizadas ordenadas por desarrollador
        </p>
        
        <div id="sprintInfoContainer"></div>
        
        <div class="report-table-wrapper">
          <table class="report-table" id="reportTable">
            <thead>
              <tr>
                <th>Tarea</th>
                <th>Estado</th>
                <th>Prioridad</th>
                <th>Horas Estimadas</th>
                <th>Horas Reales</th>
                <th>Completada</th>
              </tr>
            </thead>
            <tbody id="reportTableBody">
              <tr>
                <td colspan="6" class="no-data-message">Use los filtros globales arriba para ver el reporte</td>
              </tr>
            </tbody>
          </table>
        </div>
      </section>
    </main>
  </div>

  <script>
    // ==================== ESTADO GLOBAL DE FILTROS ====================
    
    const appState = {
      userId: null,
      userEmail: null,
      projects: [],
      allSprints: [],
      filters: {
        projectId: null,
        sprintId: null
      }
    };

    // ==================== INICIALIZACI√ìN ====================
    
    async function initializeApp() {
      try {
        // Obtener usuario
        let userEmail = localStorage.getItem('userEmail');
        if (!userEmail) {
          const qEmail = new URLSearchParams(location.search).get('email');
          if (qEmail) userEmail = qEmail;
        }
        
        if (!userEmail) {
          console.warn('No hay email de usuario disponible');
          return;
        }
        
        appState.userEmail = userEmail;

        // Obtener userId
        const rUser = await fetch('/usuarios/by-email?email=' + encodeURIComponent(userEmail));
        if (!rUser.ok) throw new Error('Usuario no encontrado');
        const userObj = await rUser.json();
        appState.userId = userObj.id || userObj.usuarioId || userObj.usuario_id;
        
        if (!appState.userId) {
          console.warn('Usuario sin ID v√°lido');
          return;
        }

        // Cargar proyectos visibles
        const rProjects = await fetch('/proyectos/visibles/' + encodeURIComponent(appState.userId));
        if (!rProjects.ok) throw new Error('Error cargando proyectos');
        appState.projects = await rProjects.json();

        // Cargar todos los sprints de los proyectos
        await loadAllSprints();

        // Poblar filtros globales
        populateFilters();

        // Cargar datos iniciales
        loadAllCharts();
        loadTaskCompletion();
        loadFilteredSprintReport();

      } catch (err) {
        console.error('Error inicializando app:', err);
      }
    }

    async function loadAllSprints() {
      const sprints = [];
      for (const proj of appState.projects) {
        const projectId = proj.id || proj.projectId || proj.proyectoId;
        if (!projectId) continue;
        
        try {
          const rSprints = await fetch('/sprints?projectId=' + encodeURIComponent(projectId));
          if (!rSprints.ok) continue;
          const projSprints = await rSprints.json();
          
          if (Array.isArray(projSprints)) {
            projSprints.forEach(s => {
              s.projectId = projectId;
              s.projectName = proj.nombreProyecto || 'Proyecto';
              sprints.push(s);
            });
          }
        } catch (err) {
          console.debug('Error cargando sprints del proyecto', projectId, err);
        }
      }
      appState.allSprints = sprints;
    }

    function populateFilters() {
      const projectSelect = document.getElementById('projectFilter');
      const sprintSelect = document.getElementById('sprintFilter');

      // Poblar proyectos
      projectSelect.innerHTML = '<option value="">Todos los proyectos</option>';
      appState.projects.forEach(p => {
        const opt = document.createElement('option');
        opt.value = p.id || p.projectId || p.proyectoId;
        opt.textContent = p.nombreProyecto || 'Sin nombre';
        projectSelect.appendChild(opt);
      });

      // Poblar sprints (inicial: todos)
      updateSprintFilter();

      // Event listeners
      projectSelect.addEventListener('change', () => {
        updateSprintFilter();
      });

      document.getElementById('applyFilters').addEventListener('click', applyFilters);
      document.getElementById('clearFilters').addEventListener('click', clearFilters);
    }

    function updateSprintFilter() {
      const projectSelect = document.getElementById('projectFilter');
      const sprintSelect = document.getElementById('sprintFilter');
      const selectedProjectId = projectSelect.value;

      sprintSelect.innerHTML = '<option value="">Todos los sprints</option>';

      const filteredSprints = selectedProjectId
        ? appState.allSprints.filter(s => String(s.projectId) === selectedProjectId)
        : appState.allSprints;

      filteredSprints.forEach(s => {
        const opt = document.createElement('option');
        opt.value = s.id || s.sprintId;
        const sprintName = s.tituloSprint || `Sprint ${s.numero || s.id}`;
        opt.textContent = selectedProjectId 
          ? sprintName 
          : `${s.projectName} - ${sprintName}`;
        sprintSelect.appendChild(opt);
      });
    }

    function applyFilters() {
      const projectId = document.getElementById('projectFilter').value;
      const sprintId = document.getElementById('sprintFilter').value;

      appState.filters.projectId = projectId || null;
      appState.filters.sprintId = sprintId || null;

      showActiveFilters();
      loadAllCharts();
      loadFilteredSprintReport(); // ACTUALIZADO: usa filtros globales
    }

    function clearFilters() {
      document.getElementById('projectFilter').value = '';
      document.getElementById('sprintFilter').value = '';
      appState.filters.projectId = null;
      appState.filters.sprintId = null;
      updateSprintFilter();
      hideActiveFilters();
      loadAllCharts();
      showNoData('Use los filtros globales para ver el reporte');
    }

    function showActiveFilters() {
      const container = document.getElementById('activeFilters');
      const { projectId, sprintId } = appState.filters;
      
      if (!projectId && !sprintId) {
        hideActiveFilters();
        return;
      }

      let html = '<div style="display:flex;gap:8px;flex-wrap:wrap;">';
      
      if (projectId) {
        const proj = appState.projects.find(p => String(p.id || p.projectId) === projectId);
        if (proj) {
          html += `<span class="filter-badge">üìÅ ${proj.nombreProyecto || 'Proyecto'}</span>`;
        }
      }
      
      if (sprintId) {
        const sprint = appState.allSprints.find(s => String(s.id || s.sprintId) === sprintId);
        if (sprint) {
          const name = sprint.tituloSprint || `Sprint ${sprint.numero || sprint.id}`;
          html += `<span class="filter-badge">üèÉ ${name}</span>`;
        }
      }
      
      html += '</div>';
      container.innerHTML = html;
      container.style.display = 'block';
    }

    function hideActiveFilters() {
      document.getElementById('activeFilters').style.display = 'none';
    }

    // ==================== CARGAR TODAS LAS GR√ÅFICAS ====================
    
    function loadAllCharts() {
      loadSprintHours();
      loadDeveloperSprintHours();
      loadTasksCompletedByDeveloper();
    }

    // ==================== GR√ÅFICOS (actualizados con filtros) ====================
    
    // ==================== NUEVO: Gr√°fico de Horas por Sprint ====================
    
    window.sprintHoursChart = new Chart(document.getElementById("sprintHoursChart"), {
      type: "bar",
      data: {
        labels: [],
        datasets: [
          {
            label: "Horas Planificadas",
            data: [],
            backgroundColor: "#374151",
            borderColor: "#4B5563",
            borderWidth: 1
          },
          {
            label: "Horas Reales",
            data: [],
            backgroundColor: "#E1261C",
            borderColor: "#c41f15",
            borderWidth: 1
          }
        ]
      },
      options: {
        responsive: true,
        maintainAspectRatio: true,
        plugins: {
          legend: {
            display: true,
            position: 'top',
            labels: {
              color: '#e6e7ea',
              font: { size: 12, weight: '600' }
            }
          },
          tooltip: {
            backgroundColor: '#12161c',
            titleColor: '#e6e7ea',
            bodyColor: '#c8cbd2',
            borderColor: '#20242c',
            borderWidth: 1,
            padding: 12,
            displayColors: true
          }
        },
        scales: {
          x: {
            grid: { color: '#20242c' },
            ticks: { color: '#8a93a3', font: { size: 11 } }
          },
          y: {
            beginAtZero: true,
            grid: { color: '#20242c' },
            ticks: { color: '#8a93a3', font: { size: 11 } }
          }
        }
      }
    });

    // ==================== NUEVO: Gr√°fico por Developer y Sprint ====================
    
    window.developerSprintChart = new Chart(document.getElementById("developerSprintChart"), {
      type: "bar",
      data: {
        labels: [], // Nombres de sprints
        datasets: [] // Un dataset por developer
      },
      options: {
        responsive: true,
        maintainAspectRatio: true,
        plugins: {
          legend: {
            display: true,
            position: 'top',
            labels: {
              color: '#e6e7ea',
              font: { size: 12, weight: '600' }
            }
          },
          tooltip: {
            backgroundColor: '#12161c',
            titleColor: '#e6e7ea',
            bodyColor: '#c8cbd2',
            borderColor: '#20242c',
            borderWidth: 1,
            padding: 12,
            displayColors: true,
            callbacks: {
              label: function(context) {
                const dev = context.dataset.label;
                const hours = context.parsed.y;
                return `${dev}: ${hours}h`;
              }
            }
          },
        scales: {
          x: {
            grid: { color: '#20242c' },
            ticks: { color: '#8a93a3', font: { size: 11 } }
          },
          y: {
            beginAtZero: true,
            grid: { color: '#20242c' },
            ticks: { 
              color: '#8a93a3', 
              font: { size: 11 },
              callback: function(value) {
                return value + 'h';
              }
            }
          }
        }
      }
    }
    });

    // ==================== NUEVO: Gr√°fico de Tareas Terminadas por Developer y Sprint ====================
    
    window.tasksCompletedChart = new Chart(document.getElementById("tasksCompletedChart"), {
      type: "bar",
      data: {
        labels: [], // Nombres de sprints
        datasets: [] // Un dataset por developer
      },
      options: {
        responsive: true,
        maintainAspectRatio: true,
        plugins: {
          legend: {
            display: true,
            position: 'top',
            labels: {
              color: '#e6e7ea',
              font: { size: 12, weight: '600' }
            }
          },
          tooltip: {
            backgroundColor: '#12161c',
            titleColor: '#e6e7ea',
            bodyColor: '#c8cbd2',
            borderColor: '#20242c',
            borderWidth: 1,
            padding: 12,
            displayColors: true,
            callbacks: {
              label: function(context) {
                const dev = context.dataset.label;
                const count = context.parsed.y;
                return `${dev}: ${count} tarea${count !== 1 ? 's' : ''}`;
              }
            }
          }
        },
        scales: {
          x: {
            grid: { color: '#20242c' },
            ticks: { color: '#8a93a3', font: { size: 11 } }
          },
          y: {
            beginAtZero: true,
            grid: { color: '#20242c' },
            ticks: { 
              color: '#8a93a3', 
              font: { size: 11 },
              stepSize: 1,
              callback: function(value) {
                if (Number.isInteger(value)) {
                  return value;
                }
              }
            }
          }
        }
      }
    });

    // ==================== NUEVO: Reporte de √öltimo Sprint ====================
    
    async function loadLastSprintReport() {
      try {
        // 1) Obtener usuario y userId
        let userEmail = localStorage.getItem('userEmail');
        if (!userEmail) {
          const qEmail = new URLSearchParams(location.search).get('email');
          if (qEmail) userEmail = qEmail;
        }
        
        if (!userEmail) {
          console.warn('No hay email de usuario disponible');
          showNoData('No se pudo identificar el usuario');
          return;
        }

        const rUser = await fetch('/usuarios/by-email?email=' + encodeURIComponent(userEmail));
        if (!rUser.ok) throw new Error('Usuario no encontrado');
        const userObj = await rUser.json();
        const userId = userObj.id || userObj.usuarioId || userObj.usuario_id;
        
        if (!userId) {
          showNoData('Usuario sin ID v√°lido');
          return;
        }

        // 2) Obtener proyectos visibles
        const rProjects = await fetch('/proyectos/visibles/' + encodeURIComponent(userId));
        if (!rProjects.ok) throw new Error('Error cargando proyectos');
        const projects = await rProjects.json();
        
        if (!Array.isArray(projects) || projects.length === 0) {
          showNoData('No hay proyectos disponibles');
          return;
        }

        // 3) Buscar el √∫ltimo sprint activo o m√°s reciente
        let lastSprint = null;
        let lastSprintProject = null;
        let mostRecentDate = null;

        for (const proj of projects) {
          const projectId = proj.id || proj.projectId || proj.proyectoId;
          if (!projectId) continue;
          
          try {
            const rSprints = await fetch('/sprints?projectId=' + encodeURIComponent(projectId));
            if (!rSprints.ok) continue;
            const sprints = await rSprints.json();
            
            if (Array.isArray(sprints) && sprints.length > 0) {
              // Ordenar por fecha de inicio desc
              sprints.sort((a, b) => {
                const dateA = a.fechaInicio ? new Date(a.fechaInicio) : new Date(0);
                const dateB = b.fechaInicio ? new Date(b.fechaInicio) : new Date(0);
                return dateB - dateA;
              });
              
              const candidate = sprints[0];
              const candidateDate = candidate.fechaInicio ? new Date(candidate.fechaInicio) : new Date(0);
              
              if (!mostRecentDate || candidateDate > mostRecentDate) {
                mostRecentDate = candidateDate;
                lastSprint = candidate;
                lastSprintProject = proj;
              }
            }
          } catch (err) {
            console.debug('Error procesando sprints del proyecto', projectId, err);
          }
        }

        if (!lastSprint) {
          showNoData('No se encontraron sprints en los proyectos');
          return;
        }

        // 4) Obtener tareas del sprint
        const sprintId = lastSprint.id || lastSprint.sprintId;
        const rTasks = await fetch(`/sprints/${sprintId}/tasks`);
        if (!rTasks.ok) throw new Error('Error cargando tareas del sprint');
        const allTasks = await rTasks.json();

        // Filtrar solo completadas
        const completedStatuses = ['done', 'completed', 'finalizado', 'completado', 'terminado', 'closed', 'hecho'];
        const completedTasks = allTasks.filter(t => {
          const status = (t.status || '').toString().toLowerCase();
          return completedStatuses.some(cs => status.includes(cs)) || (t.completedAt != null);
        });

        if (completedTasks.length === 0) {
          showNoData('No hay tareas completadas en el √∫ltimo sprint');
          return;
        }

        // 5) Agrupar por developer
        const tasksByDev = new Map();
        completedTasks.forEach(task => {
          const devName = task.assigneeName || task.assigneeId || 'Sin asignar';
          if (!tasksByDev.has(devName)) {
            tasksByDev.set(devName, []);
          }
          tasksByDev.get(devName).push(task);
        });

        // 6) Renderizar tabla
        renderSprintReport(lastSprint, lastSprintProject, tasksByDev);

      } catch (err) {
        console.error('Error en loadLastSprintReport:', err);
        showNoData('Error cargando el reporte: ' + err.message);
      }
    }

    // ==================== NUEVO: Cargar Reporte con Filtros Globales ====================

    async function loadFilteredSprintReport() {
      try {
        const { projectId, sprintId } = appState.filters;

        // Si no hay filtros aplicados, mostrar mensaje
        if (!projectId && !sprintId) {
          showNoData('Seleccione un proyecto o sprint en los filtros globales para ver el reporte');
          return;
        }

        // Caso 1: Solo proyecto seleccionado -> Mostrar √∫ltimo sprint del proyecto
        if (projectId && !sprintId) {
          const project = appState.projects.find(p => 
            String(p.id || p.projectId || p.proyectoId) === projectId
          );

          if (!project) {
            showNoData('Proyecto no encontrado');
            return;
          }

          // Obtener sprints del proyecto
          const rSprints = await fetch('/sprints?projectId=' + encodeURIComponent(projectId));
          if (!rSprints.ok) {
            showNoData('Error cargando sprints del proyecto');
            return;
          }
          const sprints = await rSprints.json();

          if (!Array.isArray(sprints) || sprints.length === 0) {
            showNoData('No hay sprints en este proyecto');
            return;
          }

          // Ordenar por fecha de inicio desc para obtener el m√°s reciente
          sprints.sort((a, b) => {
            const dateA = a.fechaInicio ? new Date(a.fechaInicio) : new Date(0);
            const dateB = b.fechaInicio ? new Date(b.fechaInicio) : new Date(0);
            return dateB - dateA;
          });

          const lastSprint = sprints[0];
          await loadSprintTasksReport(lastSprint, project);
          return;
        }

        // Caso 2: Sprint espec√≠fico seleccionado
        if (sprintId) {
          const sprint = appState.allSprints.find(s => 
            String(s.id || s.sprintId) === sprintId
          );

          if (!sprint) {
            showNoData('Sprint no encontrado');
            return;
          }

          const project = appState.projects.find(p => 
            String(p.id || p.projectId || p.proyectoId) === String(sprint.projectId)
          );

          if (!project) {
            showNoData('Proyecto del sprint no encontrado');
            return;
          }

          await loadSprintTasksReport(sprint, project);
          return;
        }

      } catch (err) {
        console.error('Error en loadFilteredSprintReport:', err);
        showNoData('Error cargando el reporte: ' + err.message);
      }
    }

    async function loadSprintTasksReport(sprint, project) {
      try {
        const sprintId = sprint.id || sprint.sprintId;

        // Obtener tareas del sprint
        const rTasks = await fetch(`/sprints/${sprintId}/tasks`);
        if (!rTasks.ok) throw new Error('Error cargando tareas del sprint');
        const allTasks = await rTasks.json();

        // Filtrar solo completadas
        const completedStatuses = ['done', 'completed', 'finalizado', 'completado', 'terminado', 'closed', 'hecho'];
        const completedTasks = allTasks.filter(t => {
          const status = (t.status || '').toString().toLowerCase();
          return completedStatuses.some(cs => status.includes(cs)) || (t.completedAt != null);
        });

        if (completedTasks.length === 0) {
          showNoData('No hay tareas completadas en este sprint');
          return;
        }

        // Agrupar por developer
        const tasksByDev = new Map();
        completedTasks.forEach(task => {
          const devName = task.assigneeName || task.assigneeId || 'Sin asignar';
          if (!tasksByDev.has(devName)) {
            tasksByDev.set(devName, []);
          }
          tasksByDev.get(devName).push(task);
        });

        // Renderizar tabla
        renderSprintReport(sprint, project, tasksByDev);

      } catch (err) {
        console.error('Error en loadSprintTasksReport:', err);
        showNoData('Error cargando tareas: ' + err.message);
      }
    }

    function renderSprintReport(sprint, project, tasksByDev) {
      // Info del sprint
      const sprintName = sprint.tituloSprint || `Sprint ${sprint.numero || sprint.id}`;
      const projectName = project.nombreProyecto || 'Proyecto';
      const infoHtml = `
        <div class="sprint-info">
          <svg class="ico" style="width:16px;height:16px">
            <use href="#i-chart" />
          </svg>
          <span><strong>${projectName}</strong> - ${sprintName}</span>
        </div>
      `;
      document.getElementById('sprintInfoContainer').innerHTML = infoHtml;

      // Tabla
      const tbody = document.getElementById('reportTableBody');
      tbody.innerHTML = '';

      const sortedDevs = Array.from(tasksByDev.keys()).sort();
      let rowIndex = 0;

      sortedDevs.forEach(devName => {
        const tasks = tasksByDev.get(devName);
        const totalTasks = tasks.length;
        const totalHours = tasks.reduce((sum, t) => sum + (Number(t.realHours) || 0), 0);
        
        // Header del developer (expandible)
        const headerRow = document.createElement('tr');
        headerRow.className = 'dev-group-header';
        headerRow.dataset.devGroup = devName;
        headerRow.innerHTML = `
          <td colspan="6">
            <span class="expand-icon">‚ñº</span>
            <strong>${devName}</strong> - ${totalTasks} tarea${totalTasks !== 1 ? 's' : ''} completada${totalTasks !== 1 ? 's' : ''} 
            (${Math.round(totalHours * 10) / 10}h totales)
          </td>
        `;
        tbody.appendChild(headerRow);

        // Filas de tareas
        tasks.forEach(task => {
          const taskRow = document.createElement('tr');
          taskRow.className = `task-row task-group-${devName.replace(/\s+/g, '-')}`;
          
          const status = task.status || 'Completado';
          const priority = task.priority || 'medium';
          const estHours = Number(task.estimatedHours) || 0;
          const realHours = Number(task.realHours) || 0;
          const completedAt = task.completedAt 
            ? new Date(task.completedAt).toLocaleDateString('es-ES')
            : 'N/A';

          taskRow.innerHTML = `
            <td><strong>${task.title || 'Sin t√≠tulo'}</strong></td>
            <td><span class="task-status completed">${status}</span></td>
            <td><span class="task-priority ${priority.toLowerCase()}">${priority}</span></td>
            <td>${estHours.toFixed(1)}h</td>
            <td><span class="task-hours">${realHours.toFixed(1)}h</span></td>
            <td>${completedAt}</td>
          `;
          tbody.appendChild(taskRow);
          rowIndex++;
        });

        // Toggle para expandir/colapsar
        headerRow.addEventListener('click', () => {
          const groupClass = `task-group-${devName.replace(/\s+/g, '-')}`;
          const taskRows = tbody.querySelectorAll(`.${groupClass}`);
          const isCollapsed = headerRow.classList.toggle('collapsed');
          
          taskRows.forEach(row => {
            if (isCollapsed) {
              row.classList.add('hidden');
            } else {
              row.classList.remove('hidden');
            }
          });
        });
      });
    }

    function showNoData(message) {
      const tbody = document.getElementById('reportTableBody');
      tbody.innerHTML = `<tr><td colspan="6" class="no-data-message">${message}</td></tr>`;
      document.getElementById('sprintInfoContainer').innerHTML = '';
    }

    // ==================== Cargar Horas por Sprint ====================
    
    async function loadSprintHours() {
      try {
        if (!appState.projects || appState.projects.length === 0) return;

        const allSprints = [];
        const projectsToProcess = appState.filters.projectId
          ? appState.projects.filter(p => String(p.id || p.projectId) === appState.filters.projectId)
          : appState.projects;

        for (const proj of projectsToProcess) {
          const projectId = proj.id || proj.projectId || proj.proyectoId;
          if (!projectId) continue;
          
          try {
            const rSprints = await fetch('/sprints?projectId=' + encodeURIComponent(projectId));
            if (!rSprints.ok) continue;
            const sprints = await rSprints.json();
            
            if (Array.isArray(sprints)) {
              for (const sprint of sprints) {
                const sprintId = sprint.id || sprint.sprintId;
                
                // Filtro por sprint espec√≠fico
                if (appState.filters.sprintId && String(sprintId) !== appState.filters.sprintId) {
                  continue;
                }
                
                const sprintName = sprint.tituloSprint || `Sprint ${sprint.numero || sprintId}`;
                
                let plannedHours = 0;
                let realHours = 0;
                
                try {
                  const rTasks = await fetch(`/sprints/${sprintId}/tasks`);
                  if (rTasks.ok) {
                    const tasks = await rTasks.json();
                    if (Array.isArray(tasks)) {
                      plannedHours = tasks.reduce((sum, t) => sum + (Number(t.estimatedHours || 0) || 0), 0);
                      realHours = tasks.reduce((sum, t) => sum + (Number(t.realHours || 0) || 0), 0);
                    }
                  }
                } catch (err) {
                  console.debug('Error cargando tareas del sprint', sprintId, err);
                }
                
                allSprints.push({
                  name: `${proj.nombreProyecto || 'Proyecto'} - ${sprintName}`,
                  planned: Math.round(plannedHours * 10) / 10,
                  real: Math.round(realHours * 10) / 10,
                  numero: sprint.numero || 0,
                  projectName: proj.nombreProyecto || 'Proyecto'
                });
              }
            }
          } catch (err) {
            console.debug('Error procesando sprints del proyecto', projectId, err);
          }
        }

        allSprints.sort((a, b) => {
          const projCompare = a.projectName.localeCompare(b.projectName);
          if (projCompare !== 0) return projCompare;
          return a.numero - b.numero;
        });

        if (allSprints.length === 0) {
          window.sprintHoursChart.data.labels = [];
          window.sprintHoursChart.data.datasets[0].data = [];
          window.sprintHoursChart.data.datasets[1].data = [];
          window.sprintHoursChart.update();
          return;
        }

        window.sprintHoursChart.data.labels = allSprints.map(s => s.name);
        window.sprintHoursChart.data.datasets[0].data = allSprints.map(s => s.planned);
        window.sprintHoursChart.data.datasets[1].data = allSprints.map(s => s.real);
        window.sprintHoursChart.update();

      } catch (err) {
        console.error('Error en loadSprintHours:', err);
      }
    }
    

    async function loadDeveloperSprintHours() {
      try {
        if (!appState.projects || appState.projects.length === 0) return;

        const sprintDeveloperHours = new Map();
        const allDevelopers = new Set();
        const sprintNames = new Map();

        const projectsToProcess = appState.filters.projectId
          ? appState.projects.filter(p => String(p.id || p.projectId) === appState.filters.projectId)
          : appState.projects;

        for (const proj of projectsToProcess) {
          const projectId = proj.id || proj.projectId || proj.proyectoId;
          if (!projectId) continue;
          
          try {
            const rSprints = await fetch('/sprints?projectId=' + encodeURIComponent(projectId));
            if (!rSprints.ok) continue;
            const sprints = await rSprints.json();
            
            if (Array.isArray(sprints)) {
              for (const sprint of sprints) {
                const sprintId = sprint.id || sprint.sprintId;
                
                if (appState.filters.sprintId && String(sprintId) !== appState.filters.sprintId) {
                  continue;
                }
                
                const sprintName = sprint.tituloSprint || `Sprint ${sprint.numero || sprintId}`;
                const sprintKey = `${proj.nombreProyecto || 'Proyecto'} - ${sprintName}`;
                
                sprintNames.set(sprintKey, sprintKey);
                if (!sprintDeveloperHours.has(sprintKey)) {
                  sprintDeveloperHours.set(sprintKey, {});
                }
                
                try {
                  const rTasks = await fetch(`/sprints/${sprintId}/tasks`);
                  if (rTasks.ok) {
                    const tasks = await rTasks.json();
                    if (Array.isArray(tasks)) {
                      tasks.forEach(t => {
                        const devName = t.assigneeName || t.assigneeId || 'Sin asignar';
                        allDevelopers.add(devName);
                        const real = Number(t.realHours || 0);
                        if (Number.isFinite(real)) {
                          const current = sprintDeveloperHours.get(sprintKey)[devName] || 0;
                          sprintDeveloperHours.get(sprintKey)[devName] = current + real;
                        }
                      });
                    }
                  }
                } catch (err) {
                  console.debug('Error cargando tareas del sprint', sprintId, err);
                }
              }
            }
          } catch (err) {
            console.debug('Error procesando sprints del proyecto', projectId, err);
          }
        }

        if (sprintDeveloperHours.size === 0 || allDevelopers.size === 0) {
          window.developerSprintChart.data.labels = [];
          window.developerSprintChart.data.datasets = [];
          window.developerSprintChart.update();
          return;
        }

        const sortedSprints = Array.from(sprintNames.keys()).sort();
        const colors = ['#E1261C', '#3B82F6', '#10B981', '#F59E0B', '#8B5CF6', '#EC4899', '#06B6D4', '#84CC16', '#F97316', '#6366F1'];
        const sortedDevelopers = Array.from(allDevelopers).sort();
        
        const datasets = sortedDevelopers.map((dev, idx) => {
          const color = colors[idx % colors.length];
          const data = sortedSprints.map(sprintKey => {
            const hours = sprintDeveloperHours.get(sprintKey)[dev] || 0;
            return Math.round(hours * 10) / 10;
          });
          
          return {
            label: dev,
            data: data,
            backgroundColor: color,
            borderColor: color,
            borderWidth: 1
          };
        });

        window.developerSprintChart.data.labels = sortedSprints;
        window.developerSprintChart.data.datasets = datasets;
        window.developerSprintChart.update();

      } catch (err) {
        console.error('Error en loadDeveloperSprintHours:', err);
      }
    }

    async function loadTasksCompletedByDeveloper() {
      try {
        if (!appState.projects || appState.projects.length === 0) return;

        const sprintDeveloperTasks = new Map();
        const allDevelopers = new Set();
        const sprintNames = new Map();
        const completedStatuses = ['done', 'completed', 'finalizado', 'completado', 'terminado', 'closed', 'hecho'];

        const projectsToProcess = appState.filters.projectId
          ? appState.projects.filter(p => String(p.id || p.projectId) === appState.filters.projectId)
          : appState.projects;

        for (const proj of projectsToProcess) {
          const projectId = proj.id || proj.projectId || proj.proyectoId;
          if (!projectId) continue;
          
          try {
            const rSprints = await fetch('/sprints?projectId=' + encodeURIComponent(projectId));
            if (!rSprints.ok) continue;
            const sprints = await rSprints.json();
            
            if (Array.isArray(sprints)) {
              for (const sprint of sprints) {
                const sprintId = sprint.id || sprint.sprintId;
                
                if (appState.filters.sprintId && String(sprintId) !== appState.filters.sprintId) {
                  continue;
                }
                
                const sprintName = sprint.tituloSprint || `Sprint ${sprint.numero || sprintId}`;
                const sprintKey = `${proj.nombreProyecto || 'Proyecto'} - ${sprintName}`;
                
                sprintNames.set(sprintKey, sprintKey);
                if (!sprintDeveloperTasks.has(sprintKey)) {
                  sprintDeveloperTasks.set(sprintKey, {});
                }
                
                try {
                  const rTasks = await fetch(`/sprints/${sprintId}/tasks`);
                  if (rTasks.ok) {
                    const tasks = await rTasks.json();
                    if (Array.isArray(tasks)) {
                      tasks.forEach(t => {
                        const devName = t.assigneeName || t.assigneeId || 'Sin asignar';
                        allDevelopers.add(devName);
                        const status = (t.status || '').toString().toLowerCase();
                        const isCompleted = completedStatuses.some(cs => status.includes(cs)) || (t.completedAt != null);
                        if (isCompleted) {
                          const current = sprintDeveloperTasks.get(sprintKey)[devName] || 0;
                          sprintDeveloperTasks.get(sprintKey)[devName] = current + 1;
                        }
                      });
                    }
                  }
                } catch (err) {
                  console.debug('Error cargando tareas del sprint', sprintId, err);
                }
              }
            }
          } catch (err) {
            console.debug('Error procesando sprints del proyecto', projectId, err);
          }
        }

        if (sprintDeveloperTasks.size === 0 || allDevelopers.size === 0) {
          window.tasksCompletedChart.data.labels = [];
          window.tasksCompletedChart.data.datasets = [];
          window.tasksCompletedChart.update();
          return;
        }

        const sortedSprints = Array.from(sprintNames.keys()).sort();
        const colors = ['#10B981', '#3B82F6', '#F59E0B', '#E1261C', '#8B5CF6', '#EC4899', '#06B6D4', '#84CC16', '#F97316', '#6366F1'];
        const sortedDevelopers = Array.from(allDevelopers).sort();
        
        const datasets = sortedDevelopers.map((dev, idx) => {
          const color = colors[idx % colors.length];
          const data = sortedSprints.map(sprintKey => sprintDeveloperTasks.get(sprintKey)[dev] || 0);
          return {
            label: dev,
            data: data,
            backgroundColor: color,
            borderColor: color,
            borderWidth: 1
          };
        });

        window.tasksCompletedChart.data.labels = sortedSprints;
        window.tasksCompletedChart.data.datasets = datasets;
        window.tasksCompletedChart.update();

      } catch (err) {
        console.error('Error en loadTasksCompletedByDeveloper:', err);
      }
    }

    // ==================== Mantener KPIs existentes ====================
    
    async function loadTaskCompletion() {
      try {
        const userEmail = localStorage.getItem('userEmail');
        const headers = {};
        let url = '/api/tasks';
        let currentUser = null;
        
        if (userEmail) {
          headers['X-User-Email'] = userEmail;
          currentUser = userEmail;
        } else {
          const qEmail = new URLSearchParams(location.search).get('email');
          if (qEmail) {
            url += '?email=' + encodeURIComponent(qEmail);
            currentUser = qEmail;
          }
        }

        const res = await fetch(url, { headers });
        if (!res.ok) throw new Error('Error fetching tasks: ' + res.status);
        const tasks = await res.json();

        const total = Array.isArray(tasks) ? tasks.length : 0;
        const completedStatuses = ['done', 'completed', 'finalizado', 'completado', 'terminado', 'closed', 'hecho'];
        const completedTasks = (tasks || []).filter(t => {
          const s = (t.status || '').toString().toLowerCase();
          return completedStatuses.some(cs => s.includes(cs));
        });

        const completed = completedTasks.length;
        const pct = total === 0 ? 0 : Math.round((completed / total) * 100);
        const pctEl = document.getElementById('taskCompletionValue');
        if (pctEl) pctEl.textContent = pct + '%';

        function formatHours(h) {
          if (!Number.isFinite(h)) return 'N/A';
          return (Math.round(h * 10) / 10) + 'h';
        }

        // Tiempo promedio global
        try {
          const resGlobal = await fetch('/api/tasks/avg-resolution/all-tasks');
          if (resGlobal.ok) {
            const g = await resGlobal.json();
            const globalAvg = parseFloat(g.avgResolutionHoursAllTasks);
            const avgEl = document.getElementById('avgResolutionValue');
            if (avgEl) {
              avgEl.textContent = Number.isFinite(globalAvg) ? formatHours(globalAvg) : 'N/A';
            }
          }
        } catch (e) {
          console.warn('Failed to load global avg resolution:', e);
        }

        // Individual KPI
        let userKey = currentUser ? currentUser.toString().toLowerCase() : null;
        const completedForUser = userKey
          ? completedTasks.filter(t => {
              const a = (t.assigneeId || t.userEmail || '').toString().toLowerCase();
              return a === userKey;
            })
          : [];
        
        const userCount = completedForUser.length;
        const userSum = completedForUser.reduce((acc, t) => {
          const v = parseFloat(t.realHours);
          return acc + (Number.isFinite(v) ? v : 0);
        }, 0);
        const userAvg = userCount === 0 ? 0 : (userSum / userCount);
        const individualEl = document.getElementById('individualKpiValue');
        if (individualEl) {
          individualEl.textContent = userCount === 0 ? '0h' : formatHours(userAvg);
        }

        // NUEVO: ICL Promedio de todos los equipos
        await loadAverageICL();

      } catch (err) {
        console.error(err);
        const pctEl = document.getElementById('taskCompletionValue');
        if (pctEl) pctEl.textContent = 'N/A';
        const avgEl = document.getElementById('avgResolutionValue');
        if (avgEl) avgEl.textContent = 'N/A';
        const individualEl = document.getElementById('individualKpiValue');
        if (individualEl) individualEl.textContent = 'N/A';
      }
    }

    // ==================== NUEVO: Cargar ICL Promedio ====================
    
    async function loadAverageICL() {
      const iclEl = document.getElementById('avgIclValue');
      
      try {
        // Obtener todos los equipos
        const resEquipos = await fetch('/equipos');
        if (!resEquipos.ok) {
          if (iclEl) iclEl.textContent = 'N/A';
          return;
        }
        
        const equipos = await resEquipos.json();
        
        if (!Array.isArray(equipos) || equipos.length === 0) {
          if (iclEl) {
            iclEl.textContent = '0.00';
            iclEl.classList.remove('positive', 'negative');
            iclEl.classList.add('neutral');
          }
          return;
        }

        // Obtener ICL de cada equipo
        const iclPromises = equipos.map(async (equipo) => {
          try {
            const equipoId = equipo.id || equipo.equipoId;
            if (!equipoId) return null;
            
            const resICL = await fetch(`/equipos/${equipoId}/icl`);
            if (!resICL.ok) return null;
            
            const iclData = await resICL.json();
            return iclData.icl;
          } catch (e) {
            return null;
          }
        });

        const iclValues = await Promise.all(iclPromises);
        
        // Filtrar valores v√°lidos
        const validICLs = iclValues.filter(icl => 
          icl !== null && 
          typeof icl === 'number' && 
          Number.isFinite(icl)
        );

        if (validICLs.length === 0) {
          if (iclEl) {
            iclEl.textContent = 'N/A';
            iclEl.classList.remove('positive', 'negative', 'neutral');
          }
          return;
        }

        // Calcular promedio
        const avgICL = validICLs.reduce((sum, icl) => sum + icl, 0) / validICLs.length;
        const roundedICL = Math.round(avgICL * 100) / 100;

        if (iclEl) {
          iclEl.textContent = roundedICL.toFixed(2);
          
          // Aplicar clases de color seg√∫n el nivel
          iclEl.classList.remove('positive', 'negative', 'neutral');
          
          if (roundedICL <= 0.9) {
            iclEl.classList.add('positive'); // Verde - carga saludable
          } else if (roundedICL <= 1.2) {
            iclEl.classList.add('neutral'); // Azul - carga moderada
          } else {
            iclEl.classList.add('negative'); // Rojo - sobrecarga
          }
        }

        console.log(`[KPIs] ICL Promedio calculado: ${roundedICL} (${validICLs.length} equipos)`);

      } catch (err) {
        console.error('[KPIs] Error cargando ICL promedio:', err);
        if (iclEl) {
          iclEl.textContent = 'Error';
          iclEl.classList.remove('positive', 'negative', 'neutral');
        }
      }
    }

    // ==================== Ejecutar al cargar ====================
    initializeApp();
  </script>
</body>
</html>